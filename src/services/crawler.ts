import * as cheerio from 'cheerio';
import { loadConfig } from '../utils/config';
import { Category } from '../models/Category';
import { Tag } from '../models/Tag';
import { getLogger } from '../utils/logger';
import { CategoryHierarchyOrder } from '../enums/config.enum';

export interface CrawlerOptions {
  /**
   * Fetch implementation (e.g., global fetch or mocked fetch in tests)
   */
  fetchFn: (url: string) => Promise<{ text: () => Promise<string> }>;
}

export interface ParsedPostMetadata {
  url: string;
  title: string;
  publish_date: Date;
  modified_date: Date | null;
  categories: Category[];
  tags: Tag[];
}

export interface Crawler {
  /**
   * Discover all post URLs by crawling list pages with pagination.
   */
  discoverPostUrls: () => Promise<string[]>;

  /**
   * Fetch raw HTML for an individual post URL.
   */
  fetchPostHtml: (postPathOrUrl: string) => Promise<string>;

  /**
   * Parse post metadata (title, dates, categories, tags) from HTML.
   */
  parsePostMetadata: (html: string, url: string) => ParsedPostMetadata;

  /**
   * Extract featured image from post HTML.
   * @param html The HTML content of the post.
   * @returns The featured image URL or null if not found.
   */
  extractFImgUrl: (html: string) => string | null;
}

/**
 * Creates a Crawler service that discovers post URLs from a Tistory blog.
 *
 * Pagination strategy:
 * - Start from the base blog URL (treated as page=1).
 * - Next pages are generated by incrementing the `page` query parameter:
 *   - page 1: `BLOG_URL`
 *   - page 2: `BLOG_URL?page=2`
 *   - page 3: `BLOG_URL?page=3`, etc.
 * - If the next page does not exist (fetch fails), crawling stops.
 */
export const createCrawler = (options: CrawlerOptions): Crawler => {
  const config = loadConfig();
  const { fetchFn } = options;
  const logger = getLogger();

  logger.info('Crawler.createCrawler - initialized', { blogUrl: config.blogUrl });

  const postLinkSelector = config.postListLinkSelector;

  const metadataSelectors = {
    title: config.postTitleSelector,
    publishDate: config.postPublishDateSelector,
    modifiedDate: config.postModifiedDateSelector,
    category: config.postCategorySelector,
    tag: config.postTagSelector,
    featuredImage: config.postFeaturedImageSelector,
  };

  const resolveUrl = (path: string): string => {
    if (path.startsWith('http://') || path.startsWith('https://')) {
      return path;
    }

    return `${config.blogUrl.replace(/\/$/, '')}${path.startsWith('/') ? '' : '/'}${path}`;
  };

  const buildPageUrl = (page: number): string => {
    if (page === 1) {
      return config.blogUrl;
    }

    const separator = config.blogUrl.includes('?') ? '&' : '?';
    return `${config.blogUrl}${separator}page=${page}`;
  };

  const fetchPage = async (url: string): Promise<{ html: string }> => {
    logger.debug('Crawler.fetchPage - fetching list page', { url });

    const response = await fetchFn(url);
    const html = await response.text();

    logger.debug('Crawler.fetchPage - fetched list page HTML', { url, length: html.length });

    return { html };
  };

  const extractPostUrls = (html: string): string[] => {
    const $ = cheerio.load(html);
    const urls: string[] = [];

    $(postLinkSelector).each((_, element) => {
      const href = $(element).attr('href');
      if (href) {
        urls.push(resolveUrl(href));
      }
    });

    logger.debug('Crawler.extractPostUrls - extracted post URLs from page', {
      count: urls.length,
    });

    return urls;
  };

  const discoverPostUrls = async (): Promise<string[]> => {
    const discoveredUrls = new Set<string>();
    let page = 1;

    logger.info('Crawler.discoverPostUrls - start discovery');

    // 페이지 전략:
    // - 1페이지: BLOG_URL (page=1 취급)
    // - 다음 페이지: 현재 page + 1, 즉 ?page=2, ?page=3 ...
    // - 다음 페이지가 없거나(post가 없거나 fetch 실패) 하면 탐색 종료

    while (true) {
      const pageUrl = buildPageUrl(page);

      logger.debug('Crawler.discoverPostUrls - fetching page', { page, pageUrl });

      let html: string;
      try {
        const result = await fetchPage(pageUrl);
        html = result.html;
      } catch {
        logger.info('Crawler.discoverPostUrls - stopping discovery; fetch page failed', {
          page,
          pageUrl,
        });
        // 다음 페이지가 존재하지 않는 경우
        break;
      }

      const pagePostUrls = extractPostUrls(html);

      if (pagePostUrls.length === 0) {
        logger.info('Crawler.discoverPostUrls - stopping discovery; no post URLs on page', {
          page,
          pageUrl,
        });
        // 더 이상 post URL이 없는 경우
        break;
      }

      for (const url of pagePostUrls) {
        if (!discoveredUrls.has(url)) {
          discoveredUrls.add(url);
        }
      }

      logger.debug('Crawler.discoverPostUrls - accumulated URLs after page', {
        page,
        totalCount: discoveredUrls.size,
      });

      page += 1;
    }

    logger.info('Crawler.discoverPostUrls - finished discovery', {
      totalCount: discoveredUrls.size,
    });

    return Array.from(discoveredUrls);
  };

  const fetchPostHtml = async (postPathOrUrl: string): Promise<string> => {
    const targetUrl = resolveUrl(postPathOrUrl);

    logger.debug('Crawler.fetchPostHtml - fetching post HTML', { input: postPathOrUrl, targetUrl });

    const response = await fetchFn(targetUrl);
    const html = await response.text();
    const trimmed = html.trim();

    logger.debug('Crawler.fetchPostHtml - fetched post HTML', {
      targetUrl,
      length: trimmed.length,
    });

    return trimmed;
  };

  const slugify = (name: string): string => {
    // TODO: 한국어 등 비영어권 문자 처리 개선
    // TODO: slug를 만들 필요가 있는가?
    return name
      .trim()
      .toLowerCase()
      .replace(/\s+/g, '-')
      .replace(/[^\p{L}\p{N}-]/gu, '');
  };

  const parsePostMetadata = (html: string, url: string): ParsedPostMetadata => {
    logger.debug('Crawler.parsePostMetadata - parsing metadata', { url });

    const $ = cheerio.load(html);

    const titleElement = $(metadataSelectors.title).first();
    const titleFromContent = titleElement.attr('content');
    const titleFallbackText = titleElement.text();
    const titleText = (titleFromContent || titleFallbackText || '').trim() || 'Untitled';

    const publishElement = $(metadataSelectors.publishDate).first();
    const publishFromContent = publishElement.attr('content');
    const publishFromDatetime = publishElement.attr('datetime');
    const publishDateText = (
      publishFromContent ||
      publishFromDatetime ||
      publishElement.text() ||
      ''
    ).trim();
    const publishDate = new Date(publishDateText);

    const modifiedElement = $(metadataSelectors.modifiedDate).first();
    const modifiedFromContent = modifiedElement.attr('content');
    const modifiedFromDatetime = modifiedElement.attr('datetime');
    const modifiedDateText = (
      modifiedFromContent ||
      modifiedFromDatetime ||
      modifiedElement.text() ||
      ''
    ).trim();
    const modifiedDate = modifiedDateText ? new Date(modifiedDateText) : null;

    const categories: Category[] = [];
    $(metadataSelectors.category).each((_, element) => {
      const name = $(element).text().trim();
      if (!name) {
        return;
      }
      categories.push({
        name,
        slug: slugify(name),
        parent: null,
        description: null,
      });
    });

    // Tistory 카테고리는 최대 2단계만 지원된다.
    // 가장 먼저 크롤링된 2개의 카테고리만 사용하고,
    // 환경변수에 따라 부모-자식 관계를 설정한다.
    const limitedCategories: Category[] = categories.slice(0, 2);

    if (limitedCategories.length === 2) {
      const [firstCategory, secondCategory] = limitedCategories;
      const order = config.categoryHierarchyOrder;

      if (!firstCategory || !secondCategory) {
        throw new Error('Unexpected error: missing category for hierarchy assignment');
      }

      if (order === CategoryHierarchyOrder.FIRST_IS_PARENT) {
        const parent = firstCategory;
        const child = secondCategory;
        child.parent = parent;
      } else if (order === CategoryHierarchyOrder.LAST_IS_PARENT) {
        const parent = secondCategory;
        const child = firstCategory;
        child.parent = parent;
      }
    }

    // categories 배열을 제한된 결과로 교체한다.
    categories.length = 0;
    categories.push(...limitedCategories);

    const tags: Tag[] = [];
    $(metadataSelectors.tag).each((_, element) => {
      const name = $(element).text().trim();
      if (!name) {
        return;
      }
      tags.push({
        name,
        slug: slugify(name),
      });
    });

    const result: ParsedPostMetadata = {
      url,
      title: titleText,
      publish_date: publishDate,
      modified_date: modifiedDate,
      categories,
      tags,
    };

    logger.debug('Crawler.parsePostMetadata - parsed metadata summary', {
      url,
      title: result.title,
      categoryCount: result.categories.length,
      tagCount: result.tags.length,
    });

    return result;
  };

  const extractFImgUrl = (html: string): string | null => {
    logger.debug('Crawler.extractFImgUrl - extracting featured image');

    const $ = cheerio.load(html);
    const featuredImageElement = $(metadataSelectors.featuredImage).first();
    if (featuredImageElement.length < 1) return null;

    const style = featuredImageElement.attr('style');
    if (!style) return null;

    const match = style.match(/background-image:\s*url\(["']?(.*?)["']?\)/);
    if (!match || !match[1]) return null;

    const imageUrl = resolveUrl(match[1]);
    new URL(imageUrl);
    logger.debug('Crawler.extractFImgUrl - extracted featured image URL', {
      imageUrl,
    });
    return imageUrl;
  };

  return {
    discoverPostUrls,
    fetchPostHtml,
    parsePostMetadata,
    extractFImgUrl,
  };
};
