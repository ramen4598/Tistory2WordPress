import * as cheerio from 'cheerio';
import { loadConfig } from '../utils/config';
import { Category } from '../models/Category';
import { Tag } from '../models/Tag';

export interface CrawlerOptions {
  /**
   * Fetch implementation (e.g., global fetch or mocked fetch in tests)
   */
  fetchFn: (url: string) => Promise<{ text: () => Promise<string> }>;

  /**
   * CSS selector used to locate post links on list pages
   */
  postLinkSelector: string;

  /**
   * CSS selectors used to locate metadata elements in a post HTML document.
   * If not provided, sensible defaults for typical Tistory themes are used.
   */
  metadataSelectors?: {
    title: string;
    publishDate: string;
    modifiedDate: string;
    category: string;
    tag: string;
  };
}

export interface ParsedPostMetadata {
  url: string;
  title: string;
  publish_date: Date;
  modified_date: Date | null;
  categories: Category[];
  tags: Tag[];
}

export interface Crawler {
  /**
   * Discover all post URLs by crawling list pages with pagination.
   */
  discoverPostUrls: () => Promise<string[]>;

  /**
   * Fetch raw HTML for an individual post URL.
   */
  fetchPostHtml: (postPathOrUrl: string) => Promise<string>;

  /**
   * Parse post metadata (title, dates, categories, tags) from HTML.
   */
  parsePostMetadata: (html: string, url: string) => ParsedPostMetadata;
}

/**
 * Creates a Crawler service that discovers post URLs from a Tistory blog.
 *
 * Pagination strategy:
 * - Start from the base blog URL (treated as page=1).
 * - Next pages are generated by incrementing the `page` query parameter:
 *   - page 1: `BLOG_URL`
 *   - page 2: `BLOG_URL?page=2`
 *   - page 3: `BLOG_URL?page=3`, etc.
 * - If the next page does not exist (fetch fails), crawling stops.
 */
export const createCrawler = (options: CrawlerOptions): Crawler => {
  const config = loadConfig();
  const { fetchFn, postLinkSelector } = options;

  const metadataSelectors = options.metadataSelectors ?? {
    title: 'meta[name="title"]',
    publishDate: 'meta[property="article:published_time"]',
    modifiedDate: 'meta[property="article:modified_time"]',
    category: 'div.another_category h4 a',
    tag: 'div.area_tag a[rel="tag"]',
  };

  const resolveUrl = (path: string): string => {
    if (path.startsWith('http://') || path.startsWith('https://')) {
      return path;
    }

    return `${config.blogUrl.replace(/\/$/, '')}${path.startsWith('/') ? '' : '/'}${path}`;
  };

  const buildPageUrl = (page: number): string => {
    if (page === 1) {
      return config.blogUrl;
    }

    const separator = config.blogUrl.includes('?') ? '&' : '?';
    return `${config.blogUrl}${separator}page=${page}`;
  };

  const fetchPage = async (url: string): Promise<{ html: string }> => {
    const response = await fetchFn(url);
    const html = await response.text();
    return { html };
  };

  const extractPostUrls = (html: string): string[] => {
    const $ = cheerio.load(html);
    const urls: string[] = [];

    $(postLinkSelector).each((_, element) => {
      const href = $(element).attr('href');
      if (href) {
        urls.push(resolveUrl(href));
      }
    });

    return urls;
  };

  const discoverPostUrls = async (): Promise<string[]> => {
    const discoveredUrls = new Set<string>();
    let page = 1;

    // 페이지 전략:
    // - 1페이지: BLOG_URL (page=1 취급)
    // - 다음 페이지: 현재 page + 1, 즉 ?page=2, ?page=3 ...
    // - 다음 페이지가 없거나(post가 없거나 fetch 실패) 하면 탐색 종료

    while (true) {
      const pageUrl = buildPageUrl(page);

      let html: string;
      try {
        const result = await fetchPage(pageUrl);
        html = result.html;
      } catch {
        // 다음 페이지가 존재하지 않는 경우
        break;
      }

      const pagePostUrls = extractPostUrls(html);

      if (pagePostUrls.length === 0) {
        // 더 이상 post URL이 없는 경우
        break;
      }

      for (const url of pagePostUrls) {
        if (!discoveredUrls.has(url)) {
          discoveredUrls.add(url);
        }
      }

      page += 1;
    }

    return Array.from(discoveredUrls);
  };

  const fetchPostHtml = async (postPathOrUrl: string): Promise<string> => {
    const targetUrl = resolveUrl(postPathOrUrl);
    const response = await fetchFn(targetUrl);
    const html = await response.text();
    return html.trim();
  };

  const slugify = (name: string): string => {
    return name
      .trim()
      .toLowerCase()
      .replace(/\s+/g, '-')
      .replace(/[^\p{L}\p{N}-]/gu, '');
  };

  const parsePostMetadata = (html: string, url: string): ParsedPostMetadata => {
    const $ = cheerio.load(html);

    const titleElement = $(metadataSelectors.title).first();
    const titleFromContent = titleElement.attr('content');
    const titleFallbackText = titleElement.text();
    const titleText = (titleFromContent || titleFallbackText || '').trim() || 'Untitled';

    const publishElement = $(metadataSelectors.publishDate).first();
    const publishFromContent = publishElement.attr('content');
    const publishFromDatetime = publishElement.attr('datetime');
    const publishDateText = (
      publishFromContent ||
      publishFromDatetime ||
      publishElement.text() ||
      ''
    ).trim();
    const publishDate = new Date(publishDateText);

    const modifiedElement = $(metadataSelectors.modifiedDate).first();
    const modifiedFromContent = modifiedElement.attr('content');
    const modifiedFromDatetime = modifiedElement.attr('datetime');
    const modifiedDateText = (
      modifiedFromContent ||
      modifiedFromDatetime ||
      modifiedElement.text() ||
      ''
    ).trim();
    const modifiedDate = modifiedDateText ? new Date(modifiedDateText) : null;

    const categories: Category[] = [];
    $(metadataSelectors.category).each((_, element) => {
      const name = $(element).text().trim();
      if (!name) {
        return;
      }
      categories.push({
        name,
        slug: slugify(name),
        parent: null, // TODO: 계층화된 카테고리 지원 방법 고려
        description: null,
      });
    });

    const tags: Tag[] = [];
    $(metadataSelectors.tag).each((_, element) => {
      const name = $(element).text().trim();
      if (!name) {
        return;
      }
      tags.push({
        name,
        slug: slugify(name),
      });
    });

    return {
      url,
      title: titleText,
      publish_date: publishDate,
      modified_date: modifiedDate,
      categories,
      tags,
    };
  };

  return {
    discoverPostUrls,
    fetchPostHtml,
    parsePostMetadata,
  };
};
